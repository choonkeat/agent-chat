[{"name":"Domain","comment":" Shared types for the agent-chat bridge.\n\nThe Go server bridges a browser chat UI and a coding agent.\nCommunication: Agent <--stdio MCP--> Go Bridge <--WebSocket--> Browser(s)\n\nSource of truth: eventbus.go (types), tools.go (params), main.go (protocol)\n\n@docs FileRef, UserMessage\n@docs Seq, AckId, Timestamp, Version\n@docs Event, ChatMessageData, UserMessageData, DrawEventData\n@docs QuickReplies\n@docs Json\n\n","unions":[{"name":"AckId","comment":" UUID identifying a pending acknowledgment.\nCreated by the event bus, sent to browser, returned in ack messages.\n","args":[],"cases":[["AckId",["String.String"]]]},{"name":"Event","comment":" A chat event published through the event bus.\n\nSource: eventbus.go `Event` struct. The Go struct is flat (all fields\noptional), but each event type uses a specific subset of fields.\nThe ADT makes these constraints explicit.\n\n    type Event struct {\n        Type         string    `json:\"type\"`\n        Seq          int64     `json:\"seq\"`\n        Text         string    `json:\"text,omitempty\"`\n        AckID        string    `json:\"ack_id,omitempty\"`\n        QuickReplies []string  `json:\"quick_replies,omitempty\"`\n        Instructions []any     `json:\"instructions,omitempty\"`\n        Files        []FileRef `json:\"files,omitempty\"`\n        Timestamp    int64     `json:\"ts,omitempty\"`\n    }\n\n","args":[],"cases":[["AgentMessage",["Domain.ChatMessageData"]],["VerbalReply",["Domain.ChatMessageData"]],["UserMessageEvent",["Domain.UserMessageData"]],["DrawEvent",["Domain.DrawEventData"]]]},{"name":"Json","comment":" Opaque JSON value -- draw instructions are untyped JSON objects.\n","args":[],"cases":[["Json",[]]]},{"name":"Seq","comment":" Monotonic sequence number assigned to each published event.\nUsed by browser for reconnect cursor (resume from last seen seq).\n","args":[],"cases":[["Seq",["Basics.Int"]]]},{"name":"Timestamp","comment":" Unix milliseconds timestamp. Set on publish if not already present.\n","args":[],"cases":[["Timestamp",["Basics.Int"]]]},{"name":"Version","comment":" Server version string, e.g., \"0.1.6 (bcaedff)\".\nSet at build time via ldflags: `-X main.version=... -X main.commit=...`\n","args":[],"cases":[["Version",["String.String"]]]}],"aliases":[{"name":"ChatMessageData","comment":" Payload for AgentMessage and VerbalReply events.\n","args":[],"type":"{ seq : Domain.Seq, timestamp : Domain.Timestamp, text : String.String, ackId : Maybe.Maybe Domain.AckId, quickReplies : Domain.QuickReplies, files : List.List Domain.FileRef }"},{"name":"DrawEventData","comment":" Payload for DrawEvent.\n","args":[],"type":"{ seq : Domain.Seq, timestamp : Domain.Timestamp, text : String.String, instructions : List.List Domain.Json, ackId : Maybe.Maybe Domain.AckId, quickReplies : Domain.QuickReplies }"},{"name":"FileRef","comment":" Uploaded file metadata.\n\nSource: eventbus.go `FileRef` struct.\n\n    type FileRef struct {\n        Name string `json:\"name\"`\n        Path string `json:\"path\"`\n        URL  string `json:\"url\"`\n        Size int64  `json:\"size\"`\n        Type string `json:\"type,omitempty\"`\n    }\n\n","args":[],"type":"{ name : String.String, path : String.String, url : String.String, size : Basics.Int, mimeType : String.String }"},{"name":"QuickReplies","comment":" Suggested reply buttons shown to the user.\nFirst element is the primary reply; rest are alternatives.\n","args":[],"type":"List.List String.String"},{"name":"UserMessage","comment":" A text message with optional file attachments from the browser.\n\nSource: eventbus.go `UserMessage` struct.\n\n","args":[],"type":"{ text : String.String, files : List.List Domain.FileRef }"},{"name":"UserMessageData","comment":" Payload for UserMessageEvent.\n","args":[],"type":"{ seq : Domain.Seq, timestamp : Domain.Timestamp, text : String.String, files : List.List Domain.FileRef }"}],"values":[],"binops":[]},{"name":"EventBus","comment":" Event bus -- pub/sub with blocking ack and message queue.\n\nSource: eventbus.go\n\nThe event bus is the central hub connecting MCP tools to browser clients:\n\n    MCP tool -> publish -> fan-out to N WebSocket subscribers\n    Browser  -> pushMessage -> message queue -> MCP tool reads\n\nResponsibilities:\n\n  - Fan-out: publish events to all connected browser subscribers\n  - Blocking ack: createAck/resolveAck for tools that wait for user response\n  - Event log: in-memory log for browser reconnect replay\n  - Message queue: buffered channel (256) for browser -> agent messages\n  - JSONL persistence: optional disk log for history across server restarts\n\n@docs AckHandle, AckResult\n@docs publish, createAck, resolveAck\n@docs subscribe, waitForSubscriber\n@docs pushMessage, drainMessages, waitForMessages\n@docs eventsSince, pendingAckId, lastQuickReplies\n\n","unions":[{"name":"AckResult","comment":" Result received when an ack is resolved.\n\nThe browser sends either a bare \"ack\" (primary button clicked)\nor \"ack:{message}\" (user typed a response or clicked secondary button).\n\n","args":[],"cases":[["Ack",[]],["AckWithMessage",["String.String"]]]}],"aliases":[{"name":"AckHandle","comment":" Handle returned by createAck. Caller blocks on the channel until\nthe browser resolves it.\n\nSource: eventbus.go `AckHandle` struct.\n\n","args":[],"type":"{ id : Domain.AckId, channel : EventBus.AckResult }"}],"values":[{"name":"createAck","comment":" Create a pending ack. Returns a handle whose channel blocks\nuntil resolveAck is called with the matching id.\n\nSource: eventbus.go `CreateAck` method.\n\n","type":"() -> EventBus.AckHandle"},{"name":"drainMessages","comment":" Non-blocking drain of all queued user messages.\nReturns empty list if queue is empty.\n\nUsed by check\\_messages tool.\n\nSource: eventbus.go `DrainMessages` method.\n\n","type":"() -> List.List Domain.UserMessage"},{"name":"eventsSince","comment":" Return all events with seq > cursor.\nUsed by WebSocket handler to stream missed events on reconnect.\n\nSource: eventbus.go `EventsSince` method.\n\n","type":"Domain.Seq -> List.List Domain.Event"},{"name":"lastQuickReplies","comment":" Return the last quick\\_replies sent to browser, or empty.\nTracks whether the agent is waiting for input (has replies)\nor working (no replies). Sent in connected handshake.\n\nSource: eventbus.go `LastQuickReplies` method.\n\n","type":"() -> Domain.QuickReplies"},{"name":"pendingAckId","comment":" Return the first pending ack id, or Nothing.\nSent in the WebSocket connected handshake so browser can re-enable\ninput for an in-progress blocking tool.\n\nSource: eventbus.go `PendingAckID` method.\n\n","type":"() -> Maybe.Maybe Domain.AckId"},{"name":"publish","comment":" Publish an event to all subscribers and append to event log.\n\nSets timestamp to now if zero. Assigns next monotonic seq number.\nTracks lastQuickReplies: set when event has quick\\_replies,\ncleared when event is userMessage.\n\nSource: eventbus.go `Publish` method.\n\n","type":"Domain.Event -> ()"},{"name":"pushMessage","comment":" Queue a user message from the browser.\nBuffered channel capacity: 256. On overflow, drops oldest message.\n\nSource: eventbus.go `PushMessage` method.\n\n","type":"{ text : String.String, files : List.List Domain.FileRef } -> ()"},{"name":"resolveAck","comment":" Resolve a pending ack by id. Sends the result string through\nthe channel, unblocking the waiting tool.\n\nSource: eventbus.go `ResolveAck` method.\n\n","type":"{ id : Domain.AckId, result : EventBus.AckResult } -> Basics.Bool"},{"name":"subscribe","comment":" Subscribe to receive all published events.\nReturns a buffered channel (capacity 64). Non-blocking fan-out --\nif channel is full, event is dropped for that subscriber.\n\nSource: eventbus.go `Subscribe` method.\n\n","type":"() -> ()"},{"name":"waitForMessages","comment":" Block until at least one message is queued, then drain all.\n\nUsed by send\\_message and send\\_verbal\\_reply tools.\n\nSource: eventbus.go `WaitForMessages` method.\n\n","type":"() -> Result.Result String.String (List.List Domain.UserMessage)"},{"name":"waitForSubscriber","comment":" Poll until at least one subscriber is connected.\nTimeout: 30 seconds. Poll interval: 100ms.\n\nUsed by blocking MCP tools (send\\_message, send\\_verbal\\_reply, draw)\nto ensure at least one browser is watching before publishing.\n\nSource: eventbus.go `WaitForSubscriber` method.\n\n","type":"() -> Result.Result String.String ()"}],"binops":[]},{"name":"McpTools","comment":" MCP tools and resources exposed by the agent-chat server.\n\nSource: tools.go (tool registration), resources.go (resource registration)\n\nThe agent calls these tools over stdio MCP or StreamableHTTP.\nBlocking tools (send\\_message, send\\_verbal\\_reply, draw) wait for user\ninteraction before returning. Non-blocking tools (send\\_progress,\nsend\\_verbal\\_progress, check\\_messages) return immediately.\n\nMessage flow:\n\n    Agent -> MCP tool call -> event bus publish -> WebSocket -> browser\n    Browser -> user reply -> WebSocket -> message queue -> MCP tool result\n\n@docs McpTool, McpResource\n@docs MessageParams, VerbalReplyParams, DrawParams, ProgressParams\n@docs ToolResult\n@docs allResources\n\n","unions":[{"name":"McpResource","comment":" MCP resources exposed by the server.\n\nSource: resources.go `registerResources` function.\nURI scheme: `whiteboard://{name}`\n\n","args":[],"cases":[["WhiteboardInstructions",[]],["WhiteboardDiagrammingGuide",[]],["WhiteboardQuickReference",[]]]},{"name":"McpTool","comment":" All MCP tools registered in registerTools().\n\nSource: tools.go `registerTools` function.\n\nEach variant carries the tool's input parameters.\n\n","args":[],"cases":[["SendMessage",["McpTools.MessageParams"]],["SendVerbalReply",["McpTools.VerbalReplyParams"]],["Draw",["McpTools.DrawParams"]],["SendProgress",["McpTools.ProgressParams"]],["SendVerbalProgress",["McpTools.ProgressParams"]],["CheckMessages",[]]]},{"name":"ToolResult","comment":" What blocking tools return to the agent.\n\nSource: tools.go -- the text content returned in CallToolResult.\n\n","args":[],"cases":[["UserResponded",["{ formatted : String.String, messages : List.List Domain.UserMessage }"]],["DrawAcknowledged",[]],["DrawFeedback",["String.String"]],["ProgressSent",[]],["NoNewMessages",[]],["VoiceModeError",[]]]}],"aliases":[{"name":"DrawParams","comment":" Parameters for draw tool.\n\nSource: tools.go `DrawParams` struct (local to registerTools).\n\n","args":[],"type":"{ text : String.String, instructions : List.List Domain.Json, quickReply : String.String, moreQuickReplies : List.List String.String }"},{"name":"MessageParams","comment":" Parameters for send\\_message tool.\n\nSource: tools.go `MessageParams` struct.\n\n","args":[],"type":"{ text : String.String, quickReply : String.String, moreQuickReplies : List.List String.String, imageUrls : List.List String.String }"},{"name":"ProgressParams","comment":" Parameters for send\\_progress and send\\_verbal\\_progress tools.\n\nSource: tools.go `ProgressParams` and `VerbalProgressParams` structs.\n\n","args":[],"type":"{ text : String.String, imageUrls : List.List String.String }"},{"name":"VerbalReplyParams","comment":" Parameters for send\\_verbal\\_reply tool.\n\nSource: tools.go `VerbalReplyParams` struct.\nSame shape as MessageParams.\n\n","args":[],"type":"{ text : String.String, quickReply : String.String, moreQuickReplies : List.List String.String, imageUrls : List.List String.String }"}],"values":[{"name":"allResources","comment":" All registered resources.\n\n    allResources == [ WhiteboardInstructions, WhiteboardDiagrammingGuide, WhiteboardQuickReference ]\n\n","type":"List.List McpTools.McpResource"}],"binops":[]},{"name":"WebSocketProtocol","comment":" WebSocket and HTTP protocol between Go server and browser.\n\nSource: main.go `handleWebSocket` and `startHTTPServer` functions.\n\nConnection: browser connects to /ws?cursor={lastSeq}\nServer streams missed events (seq > cursor) then fans out live events.\n\n@docs ServerToClient, ClientToServer\n@docs ConnectedHandshake, HttpEndpoint\n@docs allHttpEndpoints\n\n","unions":[{"name":"ClientToServer","comment":" Messages sent from browser to server over WebSocket.\n\nSource: main.go `handleWebSocket` read loop (lines 400-424).\n\n","args":[],"cases":[["Message",["{ text : String.String, files : List.List Domain.FileRef }"]],["AckReply",["{ id : Domain.AckId, message : String.String }"]]]},{"name":"HttpEndpoint","comment":" HTTP endpoints served by the Go server.\n\nSource: main.go `startHTTPServer` function (lines 182-192).\n\n","args":[],"cases":[["WebSocket",[]],["McpStreamableHttp",[]],["Upload",[]],["UploadedFiles",[]],["ConfigJs",[]],["StaticAssets",[]]]},{"name":"ServerToClient","comment":" Messages sent from server to browser over WebSocket.\n\nSource: main.go `handleWebSocket` function.\n\n","args":[],"cases":[["Connected",["WebSocketProtocol.ConnectedHandshake"]],["StreamedEvent",["Domain.Event"]],["MessageQueued",[]]]}],"aliases":[{"name":"ConnectedHandshake","comment":" The connected handshake sent on WebSocket open.\n\nSource: main.go lines 313-321.\n\n    { \"type\": \"connected\",\n      \"version\": \"0.1.6 (bcaedff)\",\n      \"pendingAckId\": \"uuid\",    -- optional\n      \"quickReplies\": [\"Yes\", \"No\"]  -- optional\n    }\n\n","args":[],"type":"{ version : Domain.Version, pendingAckId : Maybe.Maybe Domain.AckId, quickReplies : Domain.QuickReplies }"}],"values":[{"name":"allHttpEndpoints","comment":" All HTTP endpoints.\n\n    allHttpEndpoints == [ WebSocket, McpStreamableHttp, Upload, UploadedFiles, ConfigJs, StaticAssets ]\n\n","type":"List.List WebSocketProtocol.HttpEndpoint"}],"binops":[]}]