[{"name":"Domain","comment":" Shared types for the agent-chat bridge.\n\nThe Go server bridges a browser chat UI and a coding agent.\nCommunication: Agent <--stdio MCP--> Go Bridge <--WebSocket--> Browser(s)\n\nSource of truth: eventbus.go (types), tools.go (params), main.go (protocol)\n\n@docs FileRef, UserMessage\n@docs Seq, AckId, Timestamp, Version\n@docs Event, ChatMessageData, UserMessageData, DrawEventData\n@docs QuickReplies\n@docs Json\n\n","unions":[{"name":"AckId","comment":" UUID identifying a pending acknowledgment.\nCreated by the event bus, sent to browser, returned in ack messages.\n","args":[],"cases":[["AckId",["String.String"]]]},{"name":"Event","comment":" A chat event published through the event bus.\n\nSource: eventbus.go `Event` struct. The Go struct is flat (all fields\noptional), but each event type uses a specific subset of fields.\nThe ADT makes these constraints explicit.\n\n    type Event struct {\n        Type         string    `json:\"type\"`\n        Seq          int64     `json:\"seq\"`\n        Text         string    `json:\"text,omitempty\"`\n        AckID        string    `json:\"ack_id,omitempty\"`\n        QuickReplies []string  `json:\"quick_replies,omitempty\"`\n        Instructions []any     `json:\"instructions,omitempty\"`\n        Files        []FileRef `json:\"files,omitempty\"`\n        Timestamp    int64     `json:\"ts,omitempty\"`\n    }\n\n","args":[],"cases":[["AgentMessage",["Domain.ChatMessageData"]],["VerbalReply",["Domain.ChatMessageData"]],["UserMessageEvent",["Domain.UserMessageData"]],["DrawEvent",["Domain.DrawEventData"]]]},{"name":"Json","comment":" Opaque JSON value -- draw instructions are untyped JSON objects.\n","args":[],"cases":[["Json",[]]]},{"name":"Seq","comment":" Monotonic sequence number assigned to each published event.\nUsed by browser for reconnect cursor (resume from last seen seq).\n","args":[],"cases":[["Seq",["Basics.Int"]]]},{"name":"Timestamp","comment":" Unix milliseconds timestamp. Set on publish if not already present.\n","args":[],"cases":[["Timestamp",["Basics.Int"]]]},{"name":"Version","comment":" Server version string, e.g., \"0.1.6 (bcaedff)\".\nSet at build time via ldflags: `-X main.version=... -X main.commit=...`\n","args":[],"cases":[["Version",["String.String"]]]}],"aliases":[{"name":"ChatMessageData","comment":" Payload for AgentMessage and VerbalReply events.\n","args":[],"type":"{ seq : Domain.Seq, timestamp : Domain.Timestamp, text : String.String, ackId : Maybe.Maybe Domain.AckId, quickReplies : Domain.QuickReplies, files : List.List Domain.FileRef }"},{"name":"DrawEventData","comment":" Payload for DrawEvent.\n\nNote: does NOT include a text field. The caption text is published\nas a separate AgentMessage event before the draw (see tools.go draw handler).\n\n","args":[],"type":"{ seq : Domain.Seq, timestamp : Domain.Timestamp, instructions : List.List Domain.Json, ackId : Maybe.Maybe Domain.AckId, quickReplies : Domain.QuickReplies }"},{"name":"FileRef","comment":" Uploaded file metadata.\n\nSource: eventbus.go `FileRef` struct.\n\n    type FileRef struct {\n        Name string `json:\"name\"`\n        Path string `json:\"path\"`\n        URL  string `json:\"url\"`\n        Size int64  `json:\"size\"`\n        Type string `json:\"type,omitempty\"`\n    }\n\n","args":[],"type":"{ name : String.String, path : String.String, url : String.String, size : Basics.Int, contentType : Maybe.Maybe String.String }"},{"name":"QuickReplies","comment":" Suggested reply buttons shown to the user.\nFirst element is the primary reply; rest are alternatives.\n","args":[],"type":"List.List String.String"},{"name":"UserMessage","comment":" A text message with optional file attachments from the browser.\n\nSource: eventbus.go `UserMessage` struct.\n\n","args":[],"type":"{ text : String.String, files : List.List Domain.FileRef }"},{"name":"UserMessageData","comment":" Payload for UserMessageEvent.\n","args":[],"type":"{ seq : Domain.Seq, timestamp : Domain.Timestamp, text : String.String, files : List.List Domain.FileRef }"}],"values":[],"binops":[]},{"name":"EventBus","comment":" Event bus -- pub/sub with blocking ack and message queue.\n\nSource: eventbus.go\n\nThe event bus is the central hub connecting MCP tools to browser clients:\n\n    MCP tool -> publish -> fan-out to N WebSocket subscribers\n    Browser  -> pushMessage -> message queue -> MCP tool reads\n\nResponsibilities:\n\n  - Fan-out: publish events to all connected browser subscribers\n  - Blocking ack: createAck/resolveAck for tools that wait for user response\n  - Event log: in-memory log for browser reconnect replay\n  - Message queue: buffered channel (256) for browser -> agent messages\n  - JSONL persistence: optional disk log for history across server restarts\n  - Voice mode tracking: lastVoice state determines send\\_message rejection\n\n@docs AckHandle, AckResult\n@docs Subscription\n@docs publish, createAck, resolveAck\n@docs subscribe, unsubscribe, waitForSubscriber\n@docs pushMessage, drainMessages, waitForMessages, hasQueuedMessages\n@docs eventsSince, pendingAckId, lastQuickReplies, history\n@docs setLastVoice, lastVoice\n@docs resetLog, logUserMessage, close\n@docs formatMessages\n\n","unions":[{"name":"AckResult","comment":" Result received when an ack is resolved.\n\nThe browser sends either a bare \"ack\" (primary button clicked)\nor \"ack:{message}\" (user typed a response or clicked secondary button).\n\n","args":[],"cases":[["Ack",[]],["AckWithMessage",["String.String"]]]},{"name":"Subscription","comment":" An event bus subscription. Wraps a buffered channel (capacity 64)\nthat receives all published events.\n\nSource: eventbus.go `Subscribe()` returns `chan Event`.\n\n","args":[],"cases":[]}],"aliases":[{"name":"AckHandle","comment":" Handle returned by createAck. Caller blocks on the channel until\nthe browser resolves it.\n\nSource: eventbus.go `AckHandle` struct.\n\n","args":[],"type":"{ id : Domain.AckId, channel : EventBus.AckResult }"}],"values":[{"name":"close","comment":" Flush and close the JSONL log file.\n\nSource: eventbus.go `Close` method.\n\n","type":"() -> ()"},{"name":"createAck","comment":" Create a pending ack. Returns a handle whose channel blocks\nuntil resolveAck is called with the matching id.\n\nSource: eventbus.go `CreateAck` method.\n\n","type":"() -> EventBus.AckHandle"},{"name":"drainMessages","comment":" Non-blocking drain of all queued user messages.\nReturns empty list if queue is empty.\n\nUsed by check\\_messages tool.\n\nSource: eventbus.go `DrainMessages` method.\n\n","type":"() -> List.List Domain.UserMessage"},{"name":"eventsSince","comment":" Return all events with seq > cursor.\nUsed by WebSocket handler to stream missed events on reconnect.\n\nSource: eventbus.go `EventsSince` method.\n\n","type":"Domain.Seq -> List.List Domain.Event"},{"name":"formatMessages","comment":" Format user messages into a single string for tool results.\n\nJoins multiple messages, strips voice emoji prefix, includes file\nattachment info (path, MIME type, size). Uses the \"format-messages\"\nGo template.\n\nFree function (not a method on EventBus), defined in eventbus.go.\n\nSource: eventbus.go `FormatMessages` function.\n\n","type":"List.List Domain.UserMessage -> String.String"},{"name":"hasQueuedMessages","comment":" Returns True if there are user messages waiting in the queue.\n\nUsed by blocking tools (send\\_message, send\\_verbal\\_reply, draw)\nto short-circuit: if messages are already queued, skip quick\\_replies\nand return immediately since the replies would be stale.\n\nSource: eventbus.go `HasQueuedMessages` method.\n\n","type":"() -> Basics.Bool"},{"name":"history","comment":" Return a copy of the full event log and the pending ack ID (if any).\n\nSource: eventbus.go `History` method.\n\n","type":"() -> { events : List.List Domain.Event, pendingAckId : Maybe.Maybe Domain.AckId }"},{"name":"lastQuickReplies","comment":" Return the last quick\\_replies sent to browser, or empty.\nTracks whether the agent is waiting for input (has replies)\nor working (no replies). Sent in connected handshake.\n\nSource: eventbus.go `LastQuickReplies` method.\n\n","type":"() -> Domain.QuickReplies"},{"name":"lastVoice","comment":" Returns True if the last consumed user messages contained voice input.\n\nUsed by send\\_message tool to reject with VoiceModeError.\n\nSource: eventbus.go `LastVoice` method.\n\n","type":"() -> Basics.Bool"},{"name":"logUserMessage","comment":" Append a userMessage event to the log for reconnect replay WITHOUT\nassigning a sequence number or fanning out to subscribers.\n\nThese log-only events have Seq == 0 and are not broadcast.\n\nNote: this method is defined in eventbus.go but is not currently called\nfrom main.go -- the WebSocket handler uses Publish instead. May be\ndead code or reserved for future use.\n\nSource: eventbus.go `LogUserMessage` method.\n\n","type":"{ text : String.String, files : List.List Domain.FileRef } -> ()"},{"name":"pendingAckId","comment":" Return the first pending ack id, or Nothing.\nSent in the WebSocket connected handshake so browser can re-enable\ninput for an in-progress blocking tool.\n\nSource: eventbus.go `PendingAckID` method.\n\n","type":"() -> Maybe.Maybe Domain.AckId"},{"name":"publish","comment":" Publish an event to all subscribers and append to event log.\n\nSets timestamp to now if zero. Assigns next monotonic seq number.\nTracks lastQuickReplies: set when event has quick\\_replies,\ncleared when event is userMessage.\nFan-out is non-blocking: if a subscriber channel is full, the event\nis dropped for that subscriber.\nAlso writes to JSONL log file if configured.\n\nSource: eventbus.go `Publish` method.\n\n","type":"Domain.Event -> ()"},{"name":"pushMessage","comment":" Queue a user message from the browser.\nBuffered channel capacity: 256. On overflow, drops oldest message.\n\nSource: eventbus.go `PushMessage` method.\n\n","type":"{ text : String.String, files : List.List Domain.FileRef } -> ()"},{"name":"resetLog","comment":" Clear the in-memory event log.\n\nSource: eventbus.go `ResetLog` method.\n\n","type":"() -> ()"},{"name":"resolveAck","comment":" Resolve a pending ack by id. Sends the result string through\nthe channel, unblocking the waiting tool. Returns True if the ack\nexisted and was resolved.\n\nSource: eventbus.go `ResolveAck` method.\nNote: Go takes raw strings (\"ack\" or \"ack:message\"), not AckResult.\nThe AckResult ADT models the parsed form.\n\n","type":"{ id : Domain.AckId, result : EventBus.AckResult } -> Basics.Bool"},{"name":"setLastVoice","comment":" Record whether the last consumed user messages contained voice input.\n\nVoice messages are identified by a microphone emoji prefix on the text.\nThis state is checked by send\\_message to reject calls when user is in\nvoice mode (must use send\\_verbal\\_reply instead).\n\nSource: eventbus.go `SetLastVoice` method.\n\n","type":"Basics.Bool -> ()"},{"name":"subscribe","comment":" Subscribe to receive all published events.\nReturns a Subscription (buffered channel, capacity 64). Non-blocking\nfan-out -- if channel is full, event is dropped for that subscriber.\nCall unsubscribe when done.\n\nSource: eventbus.go `Subscribe` method.\n\n","type":"() -> EventBus.Subscription"},{"name":"unsubscribe","comment":" Remove a subscriber channel, stopping event delivery.\n\nSource: eventbus.go `Unsubscribe` method.\n\n","type":"EventBus.Subscription -> ()"},{"name":"waitForMessages","comment":" Block until at least one message is queued, then drain all.\n\nUsed by send\\_message and send\\_verbal\\_reply tools.\n\nSource: eventbus.go `WaitForMessages` method.\n\n","type":"() -> Result.Result String.String (List.List Domain.UserMessage)"},{"name":"waitForSubscriber","comment":" Poll until at least one subscriber is connected.\nTimeout: 30 seconds. Poll interval: 100ms.\n\nUsed by blocking MCP tools (send\\_message, send\\_verbal\\_reply, draw)\nto ensure at least one browser is watching before publishing.\n\nSource: eventbus.go `WaitForSubscriber` method.\n\n","type":"() -> Result.Result String.String ()"}],"binops":[]},{"name":"McpTools","comment":" MCP tools and resources exposed by the agent-chat server.\n\nSource: tools.go (tool registration), resources.go (resource registration)\n\nThe agent calls these tools over stdio MCP or StreamableHTTP.\nBlocking tools (send\\_message, send\\_verbal\\_reply, draw) wait for user\ninteraction before returning. Non-blocking tools (send\\_progress,\nsend\\_verbal\\_progress, check\\_messages) return immediately.\n\nMessage flow:\n\n    Agent -> MCP tool call -> event bus publish -> WebSocket -> browser\n    Browser -> user reply -> WebSocket -> message queue -> MCP tool result\n\nAll blocking tool results may include a \"Chat UI: {url}\" suffix\nwhen the HTTP server URL is known.\n\n@docs McpTool, McpResource\n@docs MessageParams, VerbalReplyParams, DrawParams, ProgressParams\n@docs ToolResult\n@docs allResources\n\n","unions":[{"name":"McpResource","comment":" MCP resources exposed by the server.\n\nSource: resources.go `registerResources` function.\nURI scheme: `whiteboard://{name}`\n\n","args":[],"cases":[["WhiteboardInstructions",[]],["WhiteboardDiagrammingGuide",[]],["WhiteboardQuickReference",[]]]},{"name":"McpTool","comment":" All MCP tools registered in registerTools().\n\nSource: tools.go `registerTools` function.\n\nEach variant carries the tool's input parameters.\n\n","args":[],"cases":[["SendMessage",["McpTools.MessageParams"]],["SendVerbalReply",["McpTools.VerbalReplyParams"]],["Draw",["McpTools.DrawParams"]],["SendProgress",["McpTools.ProgressParams"]],["SendVerbalProgress",["McpTools.ProgressParams"]],["CheckMessages",[]]]},{"name":"ToolResult","comment":" What MCP tools return to the agent.\n\nSource: tools.go -- the text content returned in CallToolResult.\n\nAll results from blocking tools may have a \"\\\\nChat UI: {url}\" suffix\nappended when the HTTP server URL is known.\n\n","args":[],"cases":[["UserResponded",["{ formatted : String.String, messages : List.List Domain.UserMessage }"]],["CheckedMessages",["{ formatted : String.String, messages : List.List Domain.UserMessage }"]],["DrawAcknowledged",[]],["DrawFeedback",["String.String"]],["DrawPendingMessages",[]],["ProgressSent",[]],["NoNewMessages",[]],["VoiceModeError",[]]]}],"aliases":[{"name":"DrawParams","comment":" Parameters for draw tool.\n\nSource: tools.go `DrawParams` struct (local to registerTools).\nNote: draw does NOT support imageUrls (unlike SendMessage/SendVerbalReply).\n\n","args":[],"type":"{ text : String.String, instructions : List.List Domain.Json, quickReply : String.String, moreQuickReplies : List.List String.String }"},{"name":"MessageParams","comment":" Parameters for send\\_message tool.\n\nSource: tools.go `MessageParams` struct.\n\n","args":[],"type":"{ text : String.String, quickReply : String.String, moreQuickReplies : List.List String.String, imageUrls : List.List String.String }"},{"name":"ProgressParams","comment":" Parameters for send\\_progress and send\\_verbal\\_progress tools.\n\nSource: tools.go `ProgressParams` and `VerbalProgressParams` structs\n(structurally identical).\n\n","args":[],"type":"{ text : String.String, imageUrls : List.List String.String }"},{"name":"VerbalReplyParams","comment":" Parameters for send\\_verbal\\_reply tool.\n\nSource: tools.go `VerbalReplyParams` struct.\nSame shape as MessageParams.\n\n","args":[],"type":"{ text : String.String, quickReply : String.String, moreQuickReplies : List.List String.String, imageUrls : List.List String.String }"}],"values":[{"name":"allResources","comment":" All registered resources.\n\n    allResources == [ WhiteboardInstructions, WhiteboardDiagrammingGuide, WhiteboardQuickReference ]\n\n","type":"List.List McpTools.McpResource"}],"binops":[]},{"name":"WebSocketProtocol","comment":" WebSocket and HTTP protocol between Go server and browser.\n\nSource: main.go `handleWebSocket` and `startHTTPServer` functions.\n\nConnection: browser connects to /ws?cursor={lastSeq}\nServer streams missed events (seq > cursor) then fans out live events.\n\n@docs ServerToClient, ClientToServer\n@docs ConnectedHandshake, HttpEndpoint\n@docs CliFlag, EnvVar\n@docs allHttpEndpoints\n\n","unions":[{"name":"CliFlag","comment":" Command-line flags accepted by the server.\n\nSource: main.go `main` function, flag.Parse().\n\n","args":[],"cases":[["VersionFlag",[]],["NoStdioMcp",[]],["ThemeCookie",["String.String"]],["UploadDirFlag",["String.String"]]]},{"name":"ClientToServer","comment":" Messages sent from browser to server over WebSocket.\n\nSource: main.go `handleWebSocket` read loop.\n\nThe Go read struct is:\n\n    struct {\n        Type    string    `json:\"type\"`\n        Text    string    `json:\"text\"`\n        Files   []FileRef `json:\"files\"`\n        ID      string    `json:\"id\"`\n        Message string    `json:\"message\"`\n    }\n\n","args":[],"cases":[["Message",["{ text : String.String, files : List.List Domain.FileRef }"]],["AckReply",["{ id : Domain.AckId, message : String.String }"]]]},{"name":"EnvVar","comment":" Environment variables read by the server.\n\nSource: main.go `main` and `startHTTPServer` functions.\n\n","args":[],"cases":[["AgentChatPort",[]],["AgentChatDisable",[]],["AgentChatEventLog",[]]]},{"name":"HttpEndpoint","comment":" HTTP endpoints served by the Go server.\n\nSource: main.go `startHTTPServer` function.\n\n","args":[],"cases":[["WebSocket",[]],["McpStreamableHttp",[]],["Upload",[]],["UploadedFiles",[]],["ConfigJs",[]],["StaticAssets",[]]]},{"name":"ServerToClient","comment":" Messages sent from server to browser over WebSocket.\n\nSource: main.go `handleWebSocket` function.\n\n","args":[],"cases":[["Connected",["WebSocketProtocol.ConnectedHandshake"]],["StreamedEvent",["Domain.Event"]],["MessageQueued",[]]]}],"aliases":[{"name":"ConnectedHandshake","comment":" The connected handshake sent on WebSocket open.\n\nSource: main.go `handleWebSocket` function.\n\n    { \"type\": \"connected\",\n      \"version\": \"0.1.6 (bcaedff)\",\n      \"pendingAckId\": \"uuid\",    -- optional\n      \"quickReplies\": [\"Yes\", \"No\"]  -- optional\n    }\n\n","args":[],"type":"{ version : Domain.Version, pendingAckId : Maybe.Maybe Domain.AckId, quickReplies : Domain.QuickReplies }"}],"values":[{"name":"allHttpEndpoints","comment":" All HTTP endpoints.\n\n    allHttpEndpoints == [ WebSocket, McpStreamableHttp, Upload, UploadedFiles, ConfigJs, StaticAssets ]\n\n","type":"List.List WebSocketProtocol.HttpEndpoint"}],"binops":[]}]